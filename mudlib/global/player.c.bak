/* Player.c once upon a time DW's.
 * messed with by a lot of people.
 *  > Mostly Timion <
 * Oct '95: Baldrick added the external command handler by Chrisy and
 * removed a lot from this file.
 */
#include "library.h"
#include "tune.h"
#include "login_handler.h"
#include "drinks.h"
#include "log.h"
#include "cmd.h"
#include "commands.h"
#include "timestuff.h" // Anirudh
#include "level_track.h"
#include <memoria.h> // Vilat 18.09.2002

inherit "/global/line_ed";
inherit "/global/auto_load";
inherit "/global/events";
inherit "/global/log";
inherit "/global/spells";
inherit "/global/help";
inherit "/global/more_string";
inherit "/global/finger";
inherit "/global/pweath";
inherit "/std/living/living";
inherit "/std/living/handle";
inherit "/global/psoul";
inherit "/global/guild-race";
inherit "/global/drunk";
inherit "/global/more_file";
inherit "/global/path";
inherit "/global/consent";   // Added by Wonderflug, august 95.
inherit "/global/henchmen";  // Raskolnikov (for Radix) Oct 96

#include "money.h"
#include "post.h"
#include "mail.h"
#include "player.h"

// Taniwha 14/09/1995 how long shall we disable guild commands and spells after login
#define LOGINLOCK 10
#define START_POS "/d/ss/daggerford/ladyluck"
#define STD_RACE "/std/races/human"
// OMIQ handler added by Timion to prevent Con Loss and Immort login.
#define OMIQ_HAND "/global/omiq"
#define FLAG_GAME "/d/omiq/flag/master_control"
#define IDENTD "/net/identd"

nosave int last_command, no_heal,ontime,hp_counter,combat_counter;
nosave object snoopee;
nosave string *attackers,*attacked;
int hb_counter, time_on, monitor,invis, start_time,creator, app_creator, last_log_on;
string ident,*henchmen_load,*auto_load, last_on_from, last_pos, apellido="",title;
mixed *money_array;

void set_creator(int i);
void start_player();
void run_away();
void set_title(string str);
void public_commands();
int save_me();
int save();
void set_desc(string str);
string query_title();
int query_creator();
nomask void set_name(string str);
int check_dark(int light);
int adjust_level(int i);
int ajustar_xp_necesaria(float xp,int lvl);
int query_level();
int really_quit();
int autoequip(string str);
int set_invis(int i);
// Taniwha 1997 userp() *spits*
int query_player() { return 1;}

int test_add(object ob,int flag)
{
    string prop;
    if( !::test_add(ob,flag)) return 0;
    if(this_object()->query_creator()) return 1;
    // Please forgive this next one....
    if( explode(file_name(ob),"/")[1] == "grimbrand") return 1;
    if( explode(file_name(ob),"/")[0] == "w") return 0;
    if(ob->query_spell()) return 1; // so spell effect items will still work.
    if(sizeof(deep_inventory(TO)) + sizeof(deep_inventory(ob)) > 50)
    {
	tell_object(this_object(),"You are carrying too much and overbalance.\n");
	return 0;
    }
    if(query_property("NOMULTI")) // "bad site" check
    {
	prop = ob->query_property("NOMULTI");
	if(stringp(prop) && prop != query_name())
	    return 0;
	ob->add_static_property("NOMULTI",query_name());
    }
    return 1;
}

// Taniwha 1997.
// Nasty code to take care of multiplayers
void attack()
{
    int i;
    object ob,*olist;
    string ip;
    ::attack();
    ip = query_property("NOMULTI");
    if(!stringp(ip)) return;
    if(this_object()->query_dead()) return;
    if(TO->query_property("pacified") || TO->query_level() < 5) return;
    if(!ETO->query_property("nocast"))
    {
	olist = all_inventory(ETO);
	for(i = 0; i < sizeof(olist); i++)
	{
	    ob = olist[i];
	    if(ob && ob->query_property("NOMULTI") == ip)
	    {
		if(ob->query_property("pacified")) continue;
                if(ob->query_dead()) continue;
		attack_ob(ob);
	    }
	}
    }
}
void attack_ob(object ob)
{
    // added the if's.. Baldrick.

    /*
	if (!attacked)
	  attacked=({ });
    */
    if(ob && interactive(ob) && member_array((string)ob->query_name(),attackers) == -1)
    {
	if(!pointerp(attacked)) attacked = ({ });
	attacked += ({ (string)ob->query_name() });
    }
    ::attack_ob(ob);
}

void attack_by(object ob)
{
    /*
	if (!attackers)
	  attackers=({ });
    */
    if(ob && interactive(ob) && member_array((string)ob->query_name(),attacked) == -1)
    {
	if(!pointerp(attackers)) attackers = ({ });
	attackers += ({ (string)ob->query_name() });
    }
    ::attack_by(ob);
}

string * query_player_attackers() { return attackers; }
string * query_players_attacked() { return attacked; }
void create()
{
    if (name) {
	event (children("/global/lord"), "inform", this_player()->query_name()+" called create() on "+name, "person_cheat");
	return ;
        }
    level = 0;
    living::create();
    events::create();
    pweath::create();
    psoul::create();
    line_ed::create();
    consent::create();   // Added by Wonderflug, august 95
    henchmen::create(); //Raskolnikov
    add_property("determinate", "");
    spells::create();
    money_array = ({ });
    time_on = time();
    start_time = time();
    seteuid("PLAYER");
    attackers = ({ });
    attacked = ({ });

    Str = 13;
    Dex = 10;
    Int = 11;
    Con = 11;
    Wis = 10;
    Cha = 10;

    set_thac0(200);
    max_social_points = 10;
    desc = 0;
    add_property("player", 1);
    cols = 79;
    rows = 24;
    verbose = 1;
    last_log_on = time();
    ontime = time();
    hp_counter = 0;
    race_ob = RACE_STD;
    sscanf(file_name(this_object()), "%s#", my_file_name);
    if(OMIQ_HAND->flag_in_progress()) call_out("give_me_armband",5);
} /* create() */

int query_x_time_on() { return time_on; }
/* Naah, I don't like it.. Baldrick.
void set_x_time_on(int i) { time_on = i; }
*/

/* 3rd arg isn't actually used here.  only in creator.c */
void move_player_to_start(string bong, int newp, int going_invis) {
    object money;
    mapping mail_stat;
    if (file_name(previous_object())[0..13] != "/secure/login#") {
	notify_fail("You dont have the security clearance to do that.\n");
	return ;
    }
    /* some stupid test to make sure that the previous object is /secure/login. */
    seteuid("Root");
    set_name(bong);
    //  if (query_property("guest"))

	if (LOGIN_HANDLER->query_rebooting()) {
	log_file("ENTER_SOSPECHOSO", sprintf("Enter : %15-s %s (clonando?)[%d] [%s]\n",
	name, ctime(time()), time(),
	(query_ip_name()?query_ip_name():query_ip_number())));
	}

    log_file("ENTER", sprintf("Enter : %15-s %s (guest)[%d] [%s]\n",
	name, ctime(time()), time(),
	(query_ip_name()?query_ip_name():query_ip_number())));



	// Vilat 18.09.2002

	MEMORIAH->add_ip(query_ip_number(),capitalize(name),0);



	/*
      else
	log_file("ENTER", sprintf("Enter : %15-s %s[%d]\n",
		   name, ctime(time()), time()));
    */
    if(OMIQ_HAND->flag_in_progress() &&
       (file_size("/save/playertmp/"+name+".o") > 0)) {
      tell_object(this_object(), "Restoring your flag game temporary"
                                 "character...\n");
      restore_object("/save/playertmp/"+name,1);
    }
    else
      restore_object("/players/"+name[0..0]+"/"+name,1);

    /* Hamlet added this.  For logging on invis */
    if(going_invis != -1)
	set_invis(going_invis);

    // Aragorn fix
    colour_map = 0;
    //if (!query_creator()) {
    // Colores segun bando/nivel
    if (level < 16) set_short("%^BOLD%^GREEN%^"+CAP(name)+"%^RESET%^");
    else set_short(capitalize(name));
    if (!cols) cols = 79;
    add_property("determinate", "");
    if (this_player()->query_creator()) seteuid(name);
    else seteuid("PLAYER");
    write("Te conectaste por ultima vez desde "+last_on_from+".\n");
    last_on_from = query_ip_name(this_object())+" ("+
    query_ip_number(this_object())+")";
    // Taniwha 1996, unused
    //bonus_cache = ([ ]);
    //level_cache = ([ ]);
    if (time_on < -500*24*60*60)
	time_on += time();
    if (time_on > 0)
	time_on = 0;
    time_on += time();
    start_player();
    if(!msgin || msgin[0] != '@')
	msgin = msgout = mmsgin = mmsgout = 0;
    if(!msgin)
msgin = "%^BOLD%^YELLOW%^@$N %^RESET%^llega de $F.";
    if(!msgout)
        if(this_object()->query_creator())
msgin="%^BOLD%^YELLOW%^@$N %^RESET%^se va hacia $F.";
    if(!mmsgin)
        if(this_object()->query_creator())
msgin="%^BOLD%^YELLOW%^@$N aparece de la nada%^RESET%^.";
    if(!mmsgout)
	if(this_object()->query_creator())
msgin="%^BOLD%^YELLOW%^@$N %^RESET%^desaparece misteriosamente.";
    cat("doc/NEWS");
    if(file_size("/doc/NEWS.OMIQ") > 0)
	cat("/doc/NEWS.OMIQ");

    "/global/do_chat"->init_player_channels(query_property("channels"));

    if (!last_pos || (my_file_name == "/global/player" && last_pos[0..1] == "/w")
      || catch(call_other(last_pos, "??")))
    {
	last_pos = "/room/raceroom";
	move(last_pos);
    }
    else
    {
	move(last_pos);
	/*
	 * Set the old co ord if one does not already exist.  Otherwise don't
	 * destroy the already existing nameing scheme.
	 */
    }
// ALGUNOS? TODOS? xD PJS APARECEN NA MAS ENTRAR COMO NUEVOS CON 0 Pvs!
	if (newp) {
		set_hp(1);
		set_gp(1);
		set_social_points(10);
	}
    event(users(), "inform", query_cap_name() +
     " entra " + (query_property("guest")?"como invitado en ":"en ") + mud_name() +
         (newp ? " (%^BLUE%^BOLD%^Nuevo jugador%^RESET%^)":""),
      "logon");

    if(this_object()->query_creator())
	event(users(), "inform", query_cap_name() +
	  " entra " + (query_property("guest")?"como invitado en ":"en ") + mud_name()+
	  (newp ? " (%^BLUE%^BOLD%^Nuevo jugador%^RESET%^)":""),
	  "immort_logon");

    if(this_object()->query_invis() < 2)
    {
// Unless you pass WHO logged on, this is useless
	event(environment(this_object()),"login",this_object());
	//event(environment(this_object()),"login");
	say(query_cap_name()+" entra en el juego.\n", 0);
    }
    if (verbose) TO->process_input("look");
    else TO->process_input("glance");
    last_pos->enter(this_object());
    if (query_property(PASSED_OUT_PROP))
	call_out("remove_property", 10+random(30), PASSED_OUT_PROP);
    curses_start();
    mail_stat = (mapping)POSTAL_D->mail_status(query_name());
    if(mail_stat["unread"]) {
	if(mail_stat["total"] == 1)
	    write("\n        >>> Tu unica carta esta sin leer! <<<\n");
	else write("\n        >>> "+mail_stat["unread"]+" de tus "+
	      mail_stat["total"]+" cartas estan sin leer. <<<\n");
    }
    if (query_dead()) {
	money = clone_object(DEATH_SHADOW);
	money->setup_shadow(this_object());
    }
    if(query_old_property("noregen"))
	DEATH_CHAR->person_died(query_name());
    exec_alias("login","");
    last_log_on = time();
    ontime = time();

    //online_time_exceeded();  /* This just resets stuff here */
    LOGIN_HANDLER->player_logon(bong);
    if (my_file_name != "/global/player")
	if (file_size("/w/"+name+"/"+PLAYER_ERROR_LOG) > 0)
	    write("You have ERRORS in /w/"+name+"/"+PLAYER_ERROR_LOG+"\n");

	/* ident stuff.  -- Hamlet */
    if(!catch(load_object("/net/identd")))
	IDENTD->do_ident(this_object(), this_object());
} /* move_player_to_start() */

void setup_money();

void start_player() {
    int lockout;
    if (app_creator && my_file_name != "/global/player") {
	this_player()->all_commands();
	this_player()->app_commands();
    }
    if (creator && my_file_name != "/global/player") 
	this_player()->wiz_commands();
    reset_get();
    enable_commands();
    public_commands();
    parser_commands();
    handle_commands();
    force_commands();
    race_guild_commands();
    soul_commands();
    event_commands();
    finger_commands();
    communicate_commands();
    consent_commands();      // Added by Wonderflug, August 95.
    living_commands();
    spell_commands();
    logging_commands();
    editor_commands();
    arrancar_habilidades();
    set_living_name(name);
    set_no_check(1);
    set_con(Con);
    set_str(Str);
    set_int(Int);
    set_dex(Dex);
    set_wis(Wis);
    set_cha(Cha);
    reset_all();
    current_path = home_dir;
    //spells::init_spells();
    // call_out("setup_money",2);  This was needed for money, but it breaks stuff.
    setup_money();
    call_out("do_load_auto", 0);
    // Taniwha was here, 14/09/95
    add_timed_property("loading",1,50); // if they ain'
    // Helpless (relatively) for a while after you log in, you can run... but you can't hide.
    // Added to make it very undesirable to log out
    if( query_property("pacify_on") ) lockout = LOGINLOCK * 10;
    else lockout = LOGINLOCK;
    add_timed_property("noguild",1,lockout);
    add_timed_property("nocast",1,lockout);
    set_heart_beat(1);
    if (wimpy > 100)
	wimpy = 25;
} /* start_player() */

void setup_money()
{
    object money;
    // Done here after encumberance is set up
    money = clone_object(MONEY_OBJECT);
    money->set_money_array(money_array);
    money->move(this_object());

}

/* Ok.. the big question is: will the  reset() be called ?
 * Baldrick Feb '94
 * it does, but not in lord.c and those..
 */

void reset() {
	update_tmps();
	save();
	}


// Aragorn testing
void do_auto_equip() 
{
    if((string)this_object()->query_property("autoequip") == "yes")
	this_object()->do_equip();
}

int do_load_auto() { 
    load_auto_load(auto_load, this_object());
    set_henchmen(load_auto_load(henchmen_load,environment(this_object())));
    remove_timed_property("loading");
    if (TO->query_property("autoequip")) call_out("autoequip",0);
    call_out("do_auto_equip",3);
} /* do_load_auto() */

int is_player() {
    if (my_file_name == "/global/player") return 1;
    else return 0;
}

void public_commands() {
    	add_action("do_clear_screen","clear");
    	add_action("help_func","help");
    	add_action("help_func","ayuda");
    	add_action("restart_heart_beat", "restart");
    	add_action("stop","stop");
    	add_action("stop","parar");
    	add_action("invent","inventario");
	add_action("invent","i");
    	add_action("brief_verbose","brief");
    	add_action("brief_verbose", "verbose");
    	add_action("save","save");
    	add_action("save","grabar");
    	add_action("quit","quit");
    	add_action("quit","salir");
    	add_action("do_advance_level","avanzar");
    	add_action("review", "review");
    	add_action("examine","examinar");
    	add_action("monitor", "monitor");
    	add_action("do_refresh", "refresh");
    	add_action("do_retire", "retire");
    	add_action("do_retire", "retirar");
    	add_action("autoequip","autoequip");
	add_action("do_equip","equip");
	} /* public_commands() */

int do_cmd(string tail) {
    	string verb, t;
    	sscanf(tail, "%s %s", verb, t);
    	if(!verb) verb = tail;
    	return (int)CMD_HANDLER->cmd(verb, t, this_object());
	}

int invent()
{
    write(query_living_contents(1));
    return 1;
}

int glance(string arg)
{
    // Externalized - Radix
    if(!arg) return do_cmd("glance");
    return do_cmd("glance " +arg);
}

int look_me(string arg)
{
    // Externalized - Radix
    if(!arg) return do_cmd("look");
    return do_cmd("look " +arg);
}

int setmin(string str)
{
    msgin = str;
    return 1;
}

int setmout(string str)
{
    msgout = str;
    return 1;
}

int setmmin(string str)
{
    mmsgin = str;
    return 1;
}

int setmmout(string str)
{
    mmsgout = str;
    return 1;
}

int review() {
    write("Entry  : " + extract(msgin, 1) + "\n");
    write("Exit   : " + extract(msgout, 1) + "\n");
    write("MEntry : " + extract(mmsgin, 1) + "\n");
    write("MExit  : " + extract(mmsgout, 1) + "\n");
    write("Editor : " + editor + "\n");
    return 1;
}

int examine(string arg) {
    return look_me(arg);
}

string short(int dark) {
    string str;

    if (!interactive(this_object()))
    {
	str = "La estatua lagueada de ";
	// Added by Radix .. they still have to go thru really_quit()
	call_out("quit",0);
    }
    else
	str = "";
    return str+::short(dark);
}

string combat_short(int dark) {
	return short(dark);
}

/* This is my way to get rid of the stupid set_level thingie.. 
 * Baldrick. */
int adjust_level(int i) {
    if ((level + i) > 100) return notify_fail("Olvidalo.\n");

    if (guild_ob) guild_ob->new_levels(i, this_object());

    level += i;
    this_object()->recalc_stats(i);
    }


int brief_verbose(string str) {
    if (str == "on")
	verbose = (query_verb() == "verbose");
    else if (str == "off")
	verbose = (query_verb() == "brief");
    else if (str) {
	notify_fail("Uso: "+query_verb()+" <on/off>\n");
	return 0;
    } else
	verbose = !verbose;

    if (verbose)
	write ("Estas en modo detallado (verbose).\n");
    else
	write("Estas en modo breve (brief).\n");
    return 1;
}

int query_verbose()
{
    return verbose;
}

nomask int save() 
{
    if (my_file_name == "/global/player" || query_verb() == "save")
	tell_object(this_object(), "Grabando...\n");
	if (!LOGIN_HANDLER->query_rebooting())
    		save_me();
    return 1;
}

/** Henchmen stuff, Raskolnikov for Radix **/
void henchmen_owner_leave()
{
    int i;
    object *mons = this_object()->query_henchmen();

    mons -= ({ 0 });

    for(i=0;i<sizeof(mons);i++)
	catch(mons[i]->owner_left());

    return;
}

void henchmen_save()
{
    int i;
    object *obs = this_object()->query_henchmen();

    obs -= ({ 0 });

    for(i=0;i<sizeof(obs);i++)
	catch(obs[i]->save_my_data());
    henchmen_load = create_auto_load(obs);

    return;
}
int save_me() 
{
    object ob;
    mixed old;

    if (query_loading() || query_property("loading"))
    {
	return 0;
    }

    if (query_property("guest")) {
	write("Los invitados no pueden salvar...\n");
	return 0;
    }

    // Fix by Wonderflug.  Saving object is a bad idea.
    if ( name == "object" )
	return 0;
    if ((ob = present("Some Money For Me", this_object())))
	money_array = (mixed *)ob->query_money_array();
    else
	money_array = ({ });
    if( guild_ob && ( (file_size(guild_ob) > 0) || 
	(file_size(guild_ob+".c") > 0) ) )
	guild_ob->player_save();
    if (race_ob)
	race_ob->player_save();
    old = geteuid();
    if (environment())
	last_pos = file_name(environment());
    else
	last_pos = "/room/raceroom";
    auto_load = create_auto_load(all_inventory());
    henchmen_save();
    time_on -= time();
    // ntime_last_saved -= time();
    seteuid("Root");
    if(OMIQ_HAND->flag_in_progress() &&
//          OMIQ_HAND->is_playing_flag(this_object())) {
            1) {
      tell_object(this_object(), "Saves during the flag game are" 
                                 "temporary...\n");
      catch(save_object("/save/playertmp/"+name,1));
    }
    else
      catch(save_object("/players/"+name[0..0]+"/"+name,1));
    seteuid(old);
    time_on += time();
    // ntime_last_saved += time();
    /* Time-limit check.  Hamlet */
    /*
    if(!query_static_property("QUITTING") && online_time_exceeded())
    {
      tell_object(this_object(),"Your time-limit has been exceeded.  "
		  "Quitting...\n");
      call_out("quit",10);
    }
    */
} /* save_me() */

int quit()
{
    int foo;
    if (query_loading() || query_property("loading"))
    {
	notify_fail("Todavia se esta cargando el equipo, espera a que termine.\n");
	return 0;
    } 
    tell_object(this_object(),"Saliendo.\n");
    if (foo = this_object()->query_fighting())
    {
	tell_object(this_object(),"Estas en peleas, tardara un poco.\n");
	save();
	call_out("really_quit", query_level()*foo);
    }
    else
	this_object()->really_quit();
    return 1;
} /* quit */

int really_quit()
{
    object *ob, money,*armas, *armaduras;
    string *armaequipo, *armaduraequipo;
    object frog, frog2;
    int i,a;

    // Vilat 31.08.2002
    // Inicializar los arrays para poder anyadir luego elementos
    	armaequipo=({ });
    	armaduraequipo=({ });
    // Esto almacena lo que se lleva sujeto y lo que se lleva puesto
    	armas=TO->query_held_ob();
    	armaduras=TO->query_worn_ob();
    // Esto otro sirve para guardar los nombres de las armas
	for (a=0;a<sizeof(armas);a++) {
		if (!objectp(armas[a])) continue;
		if (sizeof(armas[a]->query_alias())>=1) armaequipo+=({armas[a]->query_alias()[0]});
		else armaequipo+=({armas[a]->query_name()});
		}
    	
    // Y esto los nombres de las armaduras
    	for (a=0;a<sizeof(armaduras);a++) {
		if (!objectp(armaduras[a])) continue;
		if (sizeof(armaduras[a]->query_alias())>=1) armaduraequipo+=({armaduras[a]->query_alias()[0]});
		else armaduraequipo+=({armaduras[a]->query_name()});
		}

    // Se guarda un indice que indica el numero de armas y armaduras que llevaba
	TO->add_property("armasautoequip",sizeof(armaequipo));
	TO->add_property("armadurasautoequip",sizeof(armaduraequipo));
	
    // Aqui a ver si funciona, vale para guardar los nombres de las armas y armaduras que llevaba
    // Increible, ha funcionado a la primera o_O
	for (a=0;a<sizeof(armaequipo);a++) TO->add_property("armaautoequip"+(string)a,armaequipo[a]);
	for (a=0;a<sizeof(armaduraequipo);a++) TO->add_property("armaduraautoequip"+(string)a,armaduraequipo[a]);
	
    // Pos esta parte ya esta (increible) ahora pasamos al equipar al iniciar - Vilat 31.08.2002

    
    // Taniwha 30-01-96 see if Flugs fix works
    traverse_timed_properties();
    last_log_on = time();
    /* Hamlet added next line */
    this_object()->adjust_online_time(time() - ontime);

    /* This should send the time the player was on to an object which
       keeps track of total hours played (non-immortal)
       Anirudh - March 17, 1996 */
    if (!this_object()->query_creator())
	TIMEKEEPER->add_time(time() - ontime);

    log_file("ENTER", sprintf("Exit  : %15-s %s[%d]\n", name, 
	ctime(time())+ (query_property("guest")?"(guest)":""), time()));
    catch(editor_check_do_quit());
    //write("Thanks for playing see you next time.\n");
    tell_object(this_object(),"Gracias por jugar, hasta la proxima.\n");
    if(this_object()->query_invis() < 2)
	say(query_cap_name()+" ha salido del juego.\n");
    if(query_name() != "object")
    {
	event(users(), "inform", query_cap_name() + " sale del MUD", "logon");
	if ( this_object()->query_creator() )
	    event(users(), "inform", query_cap_name() + 
	      " sale del MUD", "immort_logon");
    }

    LOGIN_HANDLER->player_logout(query_name());
    if (race_ob)
	catch(race_ob->player_quit(this_object()));
    if (guild_ob)
	catch(guild_ob->player_quit(this_object()));
    curses_quit();
    add_static_property("QUITTING",1);
    save_me();
    saving_henchmen();
    henchmen_owner_leave();
    /* get rid of the money....
     * we dont want them taking it twice now do we?
     */
    if ((money = present("Some Money For Me", this_object())))
	money->dest_me();
    frog = first_inventory(this_object());
    while (frog) {
	frog2 = next_inventory(frog);
	if (frog->query_auto_load() ||
	  frog->query_static_auto_load())
	    frog->dest_me();
	frog = frog2;
    }

	

	// Vilat 18.09.2002

	MEMORIAH->remove_ip(query_ip_number(),capitalize(name),0);
    

	transfer_all_to(environment());
    ob = all_inventory(this_object());
    for (i=0;i<sizeof(ob);i++)
	ob[i]->dest_me();
    dest_me();
    return 1;
} /* really quit() */

int query_drunk()
{
    if (query_volume(D_ALCOHOL)>200)
	return 1;
    return 0;
}

string query_title() { return title; }
void set_title(string str) { title = str; }

nomask void set_name(string str) {
    if (name && name != "object")
	return ;
    name = str;
    set_living_name(name);
    set_main_plural(name);
} /* set_name() */


// this used to all be in long(), moved here by Radix, MArch 1996
string query_description()
{
    string s = "Ves a "+this_object()->query_cap_name();
    if (this_object()->query_female())
	s += " la mujer ";
    else 
	s += " el varon ";
    s += this_object()->query_race_name()+",\n";

    if((race_ob) && (!desc))
	s += (string)race_ob->query_desc(this_object());

    if (desc && desc != "")
	s += "\t"+desc+"\n";

	if (TO->query_group_name() != "Sin clan.") s += "Pertenece al Clan " + TO->query_group_name() +".\n";
	if (TO->query_race_group_name() != "Sin grupo racial.") {
		object r_g_ob = TO->query_race_group_ob();
		string title = TO->query_race_group_title();

		if (r_g_ob && r_g_ob->query_drow_house()) {
			s += "Es ";
			switch (title) {
				case "matrona":
					s += "la matrona ";
					break;
				case "maestro de armas":
					s += "el maestro de armas ";
					break;
				case "lord":
					s += "lord ";
				default:
					s += "miembro ";
			}
			s += "de la "+TO->query_race_group_name()+ ".\n";
		}
		else {
			s += "Es " + ((title) ? title : "miembro") + " de " +
			TO->query_race_group_name();
		}
	}
    return s;
}

string long(string str, int dark) {
    string s;

    if (str == "soul") return (string)"/obj/handlers/soul"->query_long();
    if (str == "sol" || str == "luna" || str == "tiempo") return weather_long(str);
    if (this_player() != this_object())
	if(!this_player()->query_hidden())
	    tell_object(this_object(), this_player()->query_cap_name()+" te mira.\n");

    if (this_object()->query_dead())
    {
	s = "Ves una sombra con la forma de " + this_object()->query_cap_name() + ".\n";
	return s;
    }

    // Made this its own function... Radix, March 1996

    s = (string)this_object()->query_description();
    s += capitalize(query_pronoun())+" "+health_string()+".\n";
    s += calc_extra_look(this_object());
    s += weather_extra_look();
    s += query_living_contents(0);
    return s;
} /* long() */
/* second life routine... handles the player dieing. */

int second_life() {
    	string str;
    	int i, no_dec;
    	object tmp;

    	str = query_cap_name() + " matado por ";
    	if (!sizeof(attacker_list)) str += this_player()->query_cap_name()+" (with a call)";
    	else for (i=0;i<sizeof(attacker_list);i++) if (attacker_list[i]) {
		str += attacker_list[i]->query_name()+"<"+geteuid(attacker_list[i])+">";
		attacker_list[i]->stop_fight(this_object());
		no_dec += interactive(attacker_list[i]);
	    	}
    	secure_log_file("DEATH", ctime(time())+": "+str + "\n");

    	event(users(), "inform", str, "death");
    	attacker_list = ({ });
    	for (i=0;i<sizeof(call_outed);i++) call_outed[i]->stop_fight(this_object());
    	call_outed = ({ });

    	say(query_cap_name()+" lamentablemente ha muerto.\n");
    	save_me();
    	DEATH_CHAR->person_died(query_name());
    	hp = 0;
    	gp = 0;
	ep = 0;
    	total_xp -= xp;
    	xp = 0;
    	if (!no_dec) {
		contmp = -2;
		strtmp = -2;
		dextmp = -2;
		inttmp = -2;
		wistmp = -2;
    		}
    	tmp = clone_object(DEATH_SHADOW);
    	tmp->setup_shadow(this_object());
    	return 1;
	}

void remove_ghost()
{
    // Neg. con isn't doing anything, maybe this will work- Radix
    if(this_object()->query_real_con() < 1)
    {
	tell_object(this_object(),"Algo falla... Tu "
	  "constitucion es demasiado baja para poder revivir.\n");
	return;
    }
    this_object()->set_dead(0);
    this_object()->remove_property("OMIQ_KILLED");
    // disabled 28/09/95 Taniwha, too many bugs, we can do without the hassles for now.
    if(this_player() && this_player()->query_creator()) {
	log_file("RESURRECT",ctime(time())+": "+this_player()->query_cap_name()+
	  " resurrected "+this_object()->query_cap_name()+".\n");
    }/*
    else {
	if(!OMIQ_HAND->omiq_in_progress())
	    if(this_object()->query_level() > 9) this_object()->adjust_con(-1);
    }*/
    tell_object(this_object(), "Reapareces en una forma mas solida.\n");
    say(query_cap_name() + " aparece en una forma mas solida.\n");
    this_object()->dest_death_shadow();
    if( hp <= 0) 
	hp = this_player()->query_max_hp(); /* lo cojonudo es q a veces es 2, a veces 1, a
veces 3... no rula :/ */
//hp = this_object()->query_max_hp();

    if(OMIQ_HAND->flag_in_progress())
	call_out("give_me_armband",2);
    // Taniwha, just to avoid a few problems with being raised and dying from HP later
    save();
}

/* Hamlet -- this is so noncombat rooms can keep players from healing */
void set_no_heal() { no_heal = 1; }
void set_heal() { no_heal = 0; }

int query_hb_counter()
{
    return hb_counter;
}

int query_hb_diff(int oldc)
{
    if(hb_counter > oldc) return hb_counter - oldc;
    else return oldc - hb_counter;
}




/*
 * the heart beat. bounce what does this do? we arent going to tell you
 */

void heal_hp(int i) {
    	if(i && query_hp() < query_max_hp() && query_hp() >= 0 && !no_heal) hp++;
    	return;
	}

void heal_gp(int i, int intox) {
    	if(i && intox < 200 && query_gp() < query_max_gp() && !no_heal) gp++;
    	return;
	}

void heal_ep(int i, int intox) {
    	if(i && intox < 200 && query_ep() < query_max_ep() && !no_heal) ep++;
    	return;
	}

void heart_beat() {
    	int intox;
    	int hb_num,headache;

    	flush_queue();
    	intox = query_volume(D_ALCOHOL);
    	hb_counter++;
    	if(race_ob && !(hb_counter & 31) ) race_ob->race_heartbeat(TO);
    	if(!(hb_counter & 31)) TO->curses_heart_beat();

    	if (drunk_heart_beat(intox) && time_left > 0 && combat_counter >= 2) {
		attack();
		do_spell_effects(attackee);
		if (sizeof(attacker_list)) time_left -= (int)environment()->attack_speed();
		combat_counter = 0;
    		}
    	combat_counter++;

    	if (!interactive(this_object()) ) {
		if (name == "guest" || name == "root") {
	    		say(query_cap_name()+" se desvanece incomprensiblemente.\n");
	    		quit();
			}
		else {
	    		say(query_cap_name()+" se desvanece mientras su alma abandona Driade.\n");
	    		event(users(), "inform", query_cap_name() + " ha perdido su conexion", "link-death");
	    		save_me();
	    		this_object()->quit();
	    		}
    		}
	else {
		if (query_idle(this_object()) > MAX_IDLE*60)
			if(my_file_name != "/global/god" && my_file_name != "/global/demi" && my_file_name != "/global/lord" && my_file_name != "/global/creator") {
				say(query_cap_name()+" ha estado inactivo demasiado tiempo, "+query_pronoun()+" se desvanece en una nube de aburrimiento.\n");
				write("Has estado inactivo demasiado tiempo. Adios!\n");
				quit();
				return ;
	    			}
	    		else if (my_file_name == "/global/creator") {
				if (query_idle(TO) > MAX_IDLE * 120) {
					tell_object(TO, "Has estado inactivo a sako, aus!\n");
					quit();
					return;
					}
				else if(!TO->query_invis()) {
	    				tell_object(TO, "Has estado inactivo demasiado tiempo, poniendote en invis.\n");
	    				TO->set_invis(1);
	    				}
	    			}
	    		else {
	    			if (query_idle(TO) > MAX_IDLE * 180) {
	    				tell_object(TO, "Has estado inactivo a sako, aus!\n");
	    				quit();
	    				return;
	    				}
	    			else if(query_idle(TO) > MAX_IDLE*120) {
	    				if(TO->query_invis() < 2) {
	    					tell_object(TO, "Has estado inactivo demasiado tiempo, poniendote en invis 2.\n");
	    					TO->set_invis(2);
	    					}
	    				}
				else if(this_object()->query_invis() < 1) {
		    			tell_object(this_object(),"Has estado inactivo demasiado tiempo, poniendote en invis 1.\n");
		    			this_object()->set_invis(1);
					}
	    			}
    			}
	last_command = time() - query_idle(TO);

	if(hp_counter >= 4 && "/global/omiq.c"->omiq_in_progress()) {
		heal_hp(1);
		heal_gp(1, intox);
		heal_ep(1, intox);
		}
    	if(hp_counter >= 15) {
		if("/global/omiq.c"->flag_in_progress()) {
	  		heal_hp(5);
	  		heal_gp(5, intox);
			heal_ep(5, intox);
	  		hp_counter = -15;
			}
		else switch(query_race()) {
			default:
	  		heal_hp(1);
	    		heal_gp(1, intox);
			heal_ep(1, intox);
	    		hp_counter = 0;
			break;
			case "orco":
			heal_hp(2);
			heal_gp(2, intox);
			heal_ep(2, intox);
			hp_counter = 5;
			break;
			case "duergar":
			case "drow":
	    		if(!environment()->query_suboscuridad()) {
				if(environment()->query_light() < 25) {
		    			heal_hp(1);
		    			heal_gp(1, intox);
					heal_ep(1, intox);
		    			hp_counter = -15;
					}
				else {
		    			hp_counter = -15;
					}
	    			}
	    		else {
				heal_hp(1);
				heal_gp(1, intox);
				heal_ep(1, intox);
				hp_counter = 5;
	    			}
			break;
			}
    		}
    	hp_counter++;

    	if(headache=query_property("headache")) {
		if (!--headache) {
	    		tell_object(this_object(), "Tu dolor de cabeza desaparece.\n");
	    		remove_property("headache");
			}
		else add_property("headache",headache);
		}

    	if (intox) if (!(intox-1)) {
	    	add_property("headache",15);
	    	tell_object(this_object(),"Te empieza a doler la cabeza.\n");
	    	hp -= 2;
	    	if (hp<1) hp = 1;
		}

    	if (++hb_num%8)  {
		social_points++;
		if(social_points > max_social_points) social_points = max_social_points;

		if (hb_num > 500) {
	    		if(max_social_points < 1000) max_social_points++;
	    		hb_num = 0;
			}
    		}
    	if (sizeof(attacker_list) && wimpy && hp < max_hp*wimpy/100) run_away();
    	update_volumes();
	}

int query_monitor() { return monitor; }

void display_monitor(int i) {
    	string COLOR = "%^RED%^";
    	if(!monitor) return;
    	if(i) COLOR = "%^GREEN%^";
    	tell_object(this_object(),COLOR+sprintf("Pv: %d/%d Pm: %d/%d Pe: %d/%d\n",hp,max_hp,gp,max_gp,ep,max_ep)+"%^RESET%^\n");
    	return;
	}

int monitor(string str) {
    	if (!str) monitor = !monitor;
    	else if (str == "on") monitor = 1;
    	else if (str == "off") monitor = 0;
    	else return notify_fail("Sintaxis: monitor <on/off>\n");

    	if (monitor) write("Tu monitor de vida esta activo.\n");
    	else write("Tu monitor de vida esta inactivo.\n");
    	return 1;
	}

void run_away() 
{
    mixed *direcs;
    int i, bong;

    if ( this_object()->query_property(PASSED_OUT_PROP) )
    {
	tell_object(this_object(),"Hmm, no estas en condiciones de huir.\n");
	return ;
    }
    direcs = (mixed *)environment()->query_dest_dir();
    while (!bong && sizeof(direcs)) 
    {
	i = random(sizeof(direcs)/2)*2;
	bong = command(direcs[i]);
	if (!bong)
	    direcs = delete(direcs, i, 2);
	else
	    write("Your feet run away with you.\n");
    }
    if (!bong)
	write("You tried to run away, but no matter how much you scrabbled you "+
	  "couldn't find any exits.\n");
}

/* why have invis here ? have to find out  that Baldrick. */

int set_invis(int i) {
    	if(!previous_object()->query_lord()) {
		if(i) invis = 1;
		else invis = 0;
    		}
    	else invis = i;
	}

nomask int query_invis() { return invis; }

int help_func(string str) 
{
    string rest;
    mixed i;

    if (!str) return do_help(0);
    if (sscanf(str, "spell %s", rest) == 1) 
    {
	i = help_spell(rest);
	if (i) 
	{
	    write(i);
	    return 1;
	}
	notify_fail("No such spell as '"+rest+"'\n");
	return 0;
    }
    if (sscanf(str, "command %s", rest) == 1) 
    {
	i = help_command(rest);
	if (i) 
	{
	    write(i);
	    return 1;
	}
	notify_fail("No such command as '"+rest+"'\n");
	return 0;
    }
    i = do_help(str); /* calling /global/help.c */
    if (!i)
	if ((i = help_spell(str)))
	    write(i);
    if (!i)
	if ((i = help_command(str)))
	    write(i);
    if(str == "guild" && query_guild_ob() )
	write(query_guild_ob()->help());
    return i;
}

int query_wizard() { return creator; } /* need this for the gamed driver */
int query_app_creator() { return app_creator; }

int stop(string str)
{
	if (!query_fighting()) {
		notify_fail("Antes de parar peleas debes empezarlas.\n");
		return 0;
	}
	if (capitalize(TP->query_guild_name()) == "Asesino") {
		write("Parando peleas rapidamente.\n");
	    	call_out("really_stop", 14, str);
	}
	else {
		    write("Parando peleas, tardara un poco.\n");
		call_out("really_stop", 50, str);
	}
} /* stop */

int really_stop(string str) 
{
    int i;
    object *obs;

    if (!str)
    {
	obs = attacker_list + call_outed;
	if (!sizeof(obs))
	{
	    notify_fail("No estas luchando con nadie.\n");
	    return 0;
	}
	for (i=0;i<sizeof(obs);i++) {
		if (capitalize(TP->query_guild_name()) == "Asesino")
			if (interactive(obs[i]))
				obs[i]->stop_fight(TP);
		if (member_array(obs[i], query_attacker_list()) != -1) {
			obs -= ({obs[i--]});
			continue;
		}
	    stop_fight(obs[i]);
	}
	//if (sizeof(obs))
	//write("Has parado de luchar con "+CAP(query_multiple_short(obs))+".\n");
	return 1;
    }

    obs = find_match(str, environment());
    if (find_living(str))
	obs += ({ find_living(str) });

    if (!sizeof(obs)) 
    {
	notify_fail("No se ha podido encontrar a "+str+"\n");
	return 0;
    }
    for (i=0;i<sizeof(obs);i++)
	stop_fight(obs[i]);
    write("Ok, has parado de perseguir a "+CAP(str)+".\n");
    return 1;
}

int query_time_on() { return time_on - time(); }

int check_dark(int light) 
{
    if(this_object()->query_dead())
	return 0;
    if (race_ob)
	return (int)race_ob->query_dark(light);
    return 0;
}

int query_level() { return level; }

int restart_heart_beat()
{
    if (query_heart_beat(this_object()))
    {
	/* This should be removed at the end of april '96.. 
	 * The gp thingie that is. 
	 * Baldrick, march '96.
	 */
	write("Naah, no lo necesitas.\n");
	adjust_gp(-(level / 2));
	return 1;
    }
// Taniwha, avoids the lockup case. HB restarts, buggy spell/command kills it again
   catch(this_object()->flush_spell_effects());
    set_heart_beat(1);
    write("Ok, heart_beat restaurado.\n");
    return 1;
}

void set_snoopee(object ob) { snoopee = ob; }
object query_snoopee() { return snoopee; }

// Mmmmmmm
void set_creator(int i)
{
    /* who the hell is putting coment on this ???
       Next time I'll dest the sucker for good when I find out.. 
       Baldrick..*/
    if (file_name(previous_object()) != "/secure/master") 
    {
	write("Illegal attempt to set creator!\n");
	log_file("ILLEGAL", this_player(1)->query_name()+" Illegal attempt to "+ 
	  "set_creator at "+ctime(time())+" from "+
	  file_name(previous_object())+"\n");
	return 0;
    }
    write("Ahora eres un Creador.\n");
    creator = i;
    app_creator = i;
    home_dir = "/w/"+name;
    save_me();
}

int query_prevent_shadow(object ob) {
    if (function_exists("query_prevent_shadow", ob) ||
      function_exists("query_name", ob) ||
      function_exists("query_creator", ob) ||
      function_exists("query_app_creator", ob) ||
      function_exists("query_hidden", ob) ||
      function_exists("dest_me", ob) ||
      function_exists("save_me",ob))
	return 1;
    return 0;
}

/* Including new hack for parse_command ;) */
varargs int move(object dest, string msgin, string msgout) {
    int i;
    object env=environment();

    i = ::move(dest, msgin, msgout);
    if (!i)
	me_moveing(env);
    return i;
}

nomask int do_refresh(string str)
{
    if(!this_object()->query_creator())
    {
	write("For various reasons, refresh has been removed.\n"
	  "Please use the retire command, \"help retire\" for more "
	  "info.\n");
	return 1;
    }
    if (!str || str != "me") {
	notify_fail("Please read the docs before using this command.\n");
	return 0;
    }
    write("WARNING!  Make sure you have read the docs before doing this!\n\n"+
      "Are you sure you wish to refresh yourself? ");
    input_to("refresh2");
    return 1;
}

private nomask int refresh2(string str) {
    str = lower_case(str);
    if (str[0] != 'n' && str[0] != 'y') {
	write("Pardon?  I do not understand.  Do you want to refresh yourself? ");
	input_to("refresh2");
	return 1;
    }
    if (str[0] == 'n') {
	write("Ok, not refreshing.\n");
	return 1;
    }
    write("Doing refresh.\n");
    if (query_dead())
    {
	//remove_property("dead");
	set_dead(0);
	this_object()->dest_death_shadow();
    }
    /* Removing the guildchannel */
    if(guild_ob) // Taniwha 1995
	remove_property("chan_" + guild_ob->query_name());
    level = 0;
    Str = 10;
    Con = 10;
    Int = 10;
    Wis = 10;
    Dex = 10;
    Cha = 10;
    set_max_hp(3); // Taniwha, give them a break :), random(3) includes 0
    set_max_gp(1);
    inttmp = dextmp = wistmp = strtmp = contmp = 0;
    guild_ob = 0;
    group_ob = 0;
    race_group_ob = 0;
    map_prop = ([ ]);
    timed_prop = ([ ]);
    add_property("determinate","");
    // Taniwha 1996 skills level_cache bonus_cache commented out as skills not used NOW
    //skills = ({ });
    spells = ([ ]);
    /* No skills in this version..
    known_commands = ({sklls", "consider", "bury", });
    */
    known_commands = ({ "considerar", "enterrar", "ajustar"});
    languages = ({ "common", this_object()->query_race() });
    minor_spheres = ({ });
    major_spheres = ({ });
    neutral_spheres = ({ });
    guild_ob = 0;
    xp = 0;
    //level_cache = ([ ]);
    //bonus_cache = ([ ]);
    gr_commands = ([ ]);
    race_guild_commands();
    this_object()->add_known_command("rearrange");
    // Hmmm, maybe not use a catch..
    //"/obj/handlers/bank_handler"->refresh_account(this_object()->query_name());
    "/obj/handlers/god_handler"->remove_sacrifices(this_object());
    this_object()->clear_deity();
    set_thac0(200);
    move(load_object("/room/raceroom"));
    command("look");
    set_extreme_str(0); // Taniwha, this slipped though, Nov 1995
    write("Done.\n");
    reset_all();
    // reset_bon_stats();    Don't wanna do this.
    say(query_cap_name()+" refreshes "+query_objective()+"self.\n");
    return 1;
}

/* for creators who are playing as players */
int query_creator_playing() { return creator; }

int query_max_languages() 
{
    return (query_int()/3);
}

int teach_language(object *obs, string str)
{
    int nb, i;
    object *taught;

    taught = ({ });
    if(member_array(str, query_languages()) == -1)
	return 0;
    nb = sizeof(obs);
    if(!nb)
	return 1;
    for(i=0;i<nb;++i)
    {
	if(!living(obs[i]))
	    continue;
	if(member_array(str, (string *)obs[i]->query_languages()) != -1)
	{
	    write(obs[i]->query_cap_name()+" ya sabe hablar "+str+".\n");
	    continue;
	}
	if(obs[i]->query_max_languages()<=
	  sizeof((string *)obs[i]->query_languages()))
	{
	    write(obs[i]->query_cap_name()+" no puede aprender mas lenguajes.\n");
	    tell_object(obs[i], query_short()+" tries to teach you '"+str+"', "+
	      "but you aren't intelligent enough to learn another language.\n");
	    continue;
	}
	taught += ({ obs[i] });
    }
    nb = sizeof(taught);
    if(!nb) 
	return 1;
    for(i=0;i<nb;i++) 
    { 
	taught[i]->add_language(str);
	write("Ensenyas a "+taught[i]->query_short()+" a hablar '"+str+"'.\n");
    }
    return 1;
} /* teach_language */

string query_object_type()
{
    if (creator)
	return "A";
    return " ";
} /* query_object_type() */

nomask int do_clear_screen() {
    if( this_player(1) != this_player() )  return 0;
    tell_object(this_object(),sprintf("%c[H%c[2J",27,27));
    return 1;
}

int query_statue() { return !interactive(this_object()); }

// Vilat 31.08.2002 - Autoequip

int autoequip(string str) {
	int numeroarmas,numeroarmaduras,a;
	object *armas,*armaduras;
	// Si se pasa sin argumentos, equipa con la configuracion guardada
	if (!str) {
		// Vamos a quitar lo que lleve puesto, si es que lleva algo
    		armas=TO->query_held_ob();
    		armaduras=TO->query_worn_ob();
    		for (a=0;a<sizeof(armas);a++) {
			if (!objectp(armas[a])) continue;
			command("unhold "+armas[a]->query_name());
			}
		for (a=0;a<sizeof(armaduras);a++) {
			if (!objectp(armaduras[a])) continue;
			command("quitarse "+armaduras[a]->query_name());
			}
		// Recuperamos el numero objetos que llevaba puestos o empunyados al salir
    		numeroarmas=TO->query_property("armasautoequip");
    		numeroarmaduras=TO->query_property("armadurasautoequip");
    		// Para las armas las vamos empunyando una a una
    		for (a=0;a<numeroarmas;a++) command("hold "+TO->query_property("armaautoequip"+(string)a));
    		// Pa las armaduras lo mismo
    		for (a=0;a<numeroarmaduras;a++) {
    			command("ponerse "+TO->query_property("armaduraautoequip"+(string)a));
			// Esto es para si hay varias armaduras que no te deje stun
    			TO->remove_timed_property("passed out");
			}
    		return 1;
    		} 
    	// Si se pasa argumento, switch
    	switch (str) {
    		case "on":
		if (!TO->query_property("autoequip")) {
			TO->add_property("autoequip",1);
			tell_object(TO,"Ok. Equipamiento automatico activado.\n");
			}
		else tell_object(TO,"El equipamiento automatico ya estaba activado.\n");
		return 1;
		
		case "off":
		if (TO->query_property("autoequip")) {
			TO->remove_property("autoequip");
			tell_object(TO,"Ok. Equipamiento automatico desactivado.\n");
			}
		else tell_object(TO,"El equipamiento automatico ya estaba desactivado.\n");
		return 1;
		
		default:
		tell_object(TO,"Usa autoequip del siguiente modo:\n\t\"autoequip on\" para activar el equipamiento automatico al entrar.\n\t\"autoequip off\" para desactivar el equipamiento automatico al entrar.\n\t\"autoequip\" para volver a equiparte lo que llevabas cuando saliste del juego por ultima vez.\n");
		return 1;
		}
	return 1; 
	}

/* Add of Retire.
 * Baldrick, march '94
 */
int do_retire() 
{
    "/obj/handlers/god_handler"->remove_high_priest(this_object()->query_name(),this_object()->query_deity());
    // should probably do a more secure check, but the retire has a password.
    "/secure/master"->try_retire();
    return 1;
} /* void do_retire */

// Coded the 5th of may 1994 by Begosh@RotD
// Receiver for the chat

void receive_message( string str, string mclass)
{
    strlen(mclass) ?
    receive("\n"+this_object()->fix_string(mclass + str + "\n",strlen(mclass))):
    receive("\n"+TO->fix_string(str+"\n"));
    /*
	strlen( mclass ) ? receive( sprintf("%s%*=-s\n", mclass,
	    cols-strlen(mclass), str) ) : receive( str );
    */
} /* recieve_message */


/* This is an attempt to make it illegal to set_short on playerobjects.
 * Baldrick, aug '94
 */

void set_short(string moo)
{
    if (living(previous_object()) && !previous_object()->query_god())
    {
	tell_object(previous_object(), "Boo! Preguntale a un dios.\n");
	return;
    }
    ::set_short(moo);
}

/* Starting to implement hiding in a better fashion than the hack the hide
 * has been until now.
 * Baldrick, aug '95
 */
int query_hidden() {
    return (TO->query_invis()||TO->query_hide_shadow());
}

/* void idle_out. Used by /obj/handlers/timed.
 * instead of idleroutines in heart_beat.
 * Gotten from RD.
 * Not too sure it's better... but we'll try it.
 * baldrick, oct '95
 */
void idle_out() 
{
    if ((time() - last_command < MAX_IDLE) ||
      (my_file_name == "/global/god" || my_file_name == "/global/demi" ||
	my_file_name == "/global/lord"
	|| sizeof(users()) < 3) && interactive(this_object())) 
    {
	return ;
    }
    tell_room(environment(this_object()), capitalize(name) +
      " ha estado inactivo demasiado tiempo, " + this_object()->query_pronoun()+
      " se desvanece en una nube de aburrimiento.\n", ({this_object()}));
    tell_object(this_object(),"You idled out sorry.  Come back again!\n");
    /* chaned from really_quit() to quit() to see if the players will be able to
     * bomb out goine net dead.. 
     */
    quit();
} /* idle_out() */

/* Hamlet -- Flag game thing.  Nice and short.  Just calls handler */
void give_me_armband() {
    FLAG_GAME->assign_team(this_object());
}

/* Hamlet, Jan 1996.  The two hooks needed it internalize identd stuff */
void receive_ident_data(string id, string hosttype) {
    if(file_name(previous_object())[0..10] != "/net/identd")
	return;

    if( id != "!error!" )
	ident = id;
    else
	ident = 0;
    /* Some of the punt code will go here. */
}

string query_ident() {
    if(!"/secure/master"->query_lord(geteuid(previous_object())))
	return 0;
    return ident;
}

/* Hamlet, Feb 1996.  -- These two are needed for time_limit stuff */

nomask void set_ontime(int i)  {  ontime = i;  }
nomask int query_ontime() {  return ontime;  }
int query_prevent_reload_object() { return 1; }

int do_advance_level() {
  	int lvl,total_xp,max_lvl;
  	float xp;
  	string guild,my_race,my_race_ob,clase;

	my_race_ob=TO->query_race_ob();
	my_race=(string)my_race_ob->query_name();
	clase=TO->query_clase_ob();

  	lvl = (int)TO->query_level();
  	guild=TO->query_guild_ob();

  	if (!guild) return notify_fail("Debes alistarte en un gremio para poder avanzar.\n");


  	xp = (int)guild->query_xp_cost();

	total_xp =  ajustar_xp_necesaria(xp,lvl);
  	if(((int)TO->query_xp()) < (total_xp+1)) return notify_fail("Tu experiencia es insuficiente para avanzar.\n");

	++lvl;
  	max_lvl = guild->query_max_level(my_race);
  	if (lvl >= max_lvl) return notify_fail("No puedes avanzar por encima del nivel "+lvl+" porque eres "+capitalize(my_race)+".\n");

  	TO->adjust_level(1);
  	TO->adjust_xp(-total_xp);

	TO->set_thac0( 200 - (TO->query_level() * (int)clase->query_thac0_step()) );
	TO->set_ac(clase->query_ac(TO->query_level()));
	TO->adjust_disp_sp(TO->query_sp());

	write("Avanzas a nivel "+lvl+" y obtienes "+(string)TO->query_sp()+" puntos de Skill, que podras gastar en tu gremio.\n");
  	say(TO->query_cap_name()+" avanza de nivel.\n");
	TO->set_sp(0);
  	TO->save();
  	return 1;
	}

int ajustar_xp_necesaria(float xp,int lvl) {
  	for (int i=2;i<=lvl;i++) {
    		if (i <= 5) xp *= 1.9;
     		else if (i <= 10) xp *= 1.5;
       		else xp *= 1.1;
      		}
	return (int)xp;
	}

void set_apellido(string str) { apellido=str; }
string query_apellido() { return apellido; }

string procesar_salidas(string str) {
    mapping ss=(["n":"norte","ne":"noreste","e":"este","se":"sudeste","s":"sur","so":"sudoeste","o":"oeste","no":"noroeste","ar":"arriba","ab":"abajo","de":"dentro","fu":"fuera"]);
    if(ss[str]) return ss[str];
    else return str;
    }

mixed process_input(string str) {
	if(!TO->action_check(str)) return 1;
	if(TO->soul_com(str)) return 1;
	if(do_cmd(str)) return 1;
	str=procesar_salidas(str);
	if(TO->lower_check(str)) command(str);
	else return str;
	return 1;
	}
